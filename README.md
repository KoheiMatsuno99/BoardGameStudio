# Abstract
ガイスターというボードゲームを開発します。
ガイスターは1対1で対戦するボードゲームです。

アプリケーションURL：https://board-game-studio.vercel.app/

作成期間：2ヶ月


https://github.com/Amnis333/BoardGameStudio/assets/83019007/7eb81900-0217-4ce0-95d0-ee04d0c6d31d



# Rules

- ゲームの目的は、相手のゴーストを捕まえることです
- ゴーストは、赤と青の2色があります。ただし、相手のゴーストの種類は捕まえるまでわかりません
- 各プレイヤーから見て相手側の角のマスは脱出マスとなっています
- 自分の青ゴーストが脱出マスに到達し、その次のターンで取られなければ、そのゴーストはボードから脱出します
- 勝利条件は、「相手の青ゴーストを全て取る」「自分の赤ゴーストを全て取らせる」「自分の青ゴーストを脱出させる」のどれかを満たすことです

# Functional requirements
- 上記のルールに従い、CPUとの対戦モードを実装すること


# Non-functional requirements
- ゲームの追加が容易なコードであること
- スマホ・PCでも見やすいUIとなっていること


# Technology Stack
使用技術は以下の通り
- Frontend
    - TypeScript 4.9.5
    - React　18.2.0
- Backend
    - Python 3.9.6
    - Django 4.2.1
- CI/CD
    - GitHub Actions
- Deploy
    - Vercel
    - Elastic Beanstalk    


## Why these technology ?

### Frontend

#### TypeScript選定理由
TypeScriptを選定した最大の理由は型付けによる恩恵があるためである。明示的に型を示すことでどのような型の入出力を期待しているのかがわかるため、ソースコードの可読性を高めることができる。また、nullチェックを忘れずに行うため、オブジェクトがnullであることによる実行時エラーを未然に防ぐことができるという点も型付けによるメリットである。

#### React選定理由
今回開発するアプリは**盤面のマスごとに再レンダリングする必要があり、かつそれが頻繁に行われる**という特徴がある。そのため、フレームワークを使用せずにJavaScript/TypeScriptで開発するよりも、仮想DOMを提供しているフレームワークを使用した方が効率的な開発ができるといえる。その中でJavaScriptのメジャーなフレームワークであるVueとReactが候補に上がる。

Reactを選定した理由はアプリを開発した2023年時点で最もメジャーなフレームワークであることと、ReactはJavaScriptに近くVueよりも馴染みやすいという個人的な好みが挙げられる。また、今回開発するゲームはそれほど多くのページは必要がないため、サーバーサイドレンダリングを行う必要性は薄い。そのため、Next.jsは選定しなかった。

### Backend

#### Python選定理由
今回開発するアプリは、**高負荷なアクセスは想定されず、ターン制のボードゲームのため信頼性やレイテンシーを厳格に意識する必要性は薄い**。
そのため、大規模サービスで使用されるもののコードが冗長になりがちなGolangやJavaなどでは長所を活かしきれず、バックエンドを**短いコードで高速に開発できる**動的型付け言語の方が適していると判断した。

バックエンドにNodeJSを採用しなかったのは**フロントエンドとバックエンドの責務を明確に分離する**ことを意識したかったことが挙げられる。なぜなら、フロントエンドとバックエンドを分離することによって問題が発生した時の原因特定がしやすくなることや、アプリ全体の設計の見通しが良くなるためである。また、PHPやRubyを採用しなかったのはPythonの方が馴染みがあったという理由によるものである。

ただし、Pythonは動的型付け言語のため、事前にバグを発見することが静的型付け言語に比べると難しく、例えばオブジェクトがNoneになっていることなどによる実行時エラーが起こりやすいといった弱点がある。
そのため、Pythonの弱点である弱い型付けについては、型ヒントやmypyを使用することで**型安全性の改善と高速な開発**を両立した。

#### Django選定理由
今回Djangoを選定したのは、Pythonの中で最もメジャーなフレームワークであることが挙げられる。メジャーなフレームワークであるために開発する上で実例が多いことは大きなメリットである。
また、**多くの機能を提供しているため、高速な開発が可能**であるという点も魅力である。

特に、フロントエンドとバックエンドを分離した開発をする上でREST APIが必要となるが、REST APIを素早く構築でき、かつ枯れた技術である**Django Rest Frameworkを提供している**ことは今回Djangoを選定した上で大きな理由となった。

さらに、ORMを提供しているということもDjangoのメリットである。開発当初はデータベースを使用しておらず、Cookieによるゲームの状態管理を行っていた。しかし、リリース後、一部のブラウザで動作しないという報告をユーザーから受けた。
そこで、Cookieからデータベースによる状態管理に移行することとなったが、DjangoがデフォルトでORMを提供しているため、スムーズに移行することができた。

### CI/CD
ソースコードをGitHubで管理しているため、GitHubとの相性が良いGitHub Actionsを採用した。
バックエンドはPythonで書いているため、PEP8に準拠するようにFlake8、BlackをCIで実行させた。

# Design

## Architecture

アプリ全体の構成としては**3層アーキテクチャ**に準拠している。プレゼンテーション層はReactによる画面の描画・イベントの処理およびTypeScriptによるAPIのクライアントサイドの実装が含まれている。そして、アプリケーション層にはDjangoによるAPIのサーバーサイドの実装およびゲームのロジックが含まれている。そして、データ層ではDjangoがMySQLと通信し、データの読み書きを行うようにしている。

![image](https://github.com/Amnis333/BoardGameStudio/assets/83019007/ff2ebeba-8d6b-4828-9b24-7259b1dabe0b)


## Activity Diagram
以下はアプリケーション全体の操作フローを示したものである。

ロビー画面からゲーム説明画面に遷移した後、ゲーム画面に遷移する。そして、ゲーム終了後にはロビー画面に戻るようなフローになっている。


![image](https://github.com/Amnis333/BoardGameStudio/assets/83019007/c19d3e37-7732-4b14-9579-5d79aa5623ba)


## Class Diagram
Tableクラスがゲーム全体の状態を管理する役割を担っている。そして、ゲームに必要な情報としてプレイヤーの情報を扱うPlayerクラスと各マスの情報を扱うBlockクラスをメンバー変数として含めている。
そして、Blockクラスにはコマの情報を扱うPieceクラスをメンバー変数として含ませている。これにより、どのマスにどのコマがあるかを管理することができる。

そして、設計全体のポイントはPieceクラス-Blockクラス-Tableクラスが直列な関係にあるという点である。

つまり、TableクラスにBlockクラスの二次元配列をメンバー変数として持つことで、**各コマの位置情報をTableクラスが行列形式で一元管理できる。**
これにより、**コマの位置情報の取得や更新が直感的で簡潔な実装**になった。

![image](https://github.com/Amnis333/BoardGameStudio/assets/83019007/3bad1098-bd9c-4057-9e33-640a32ff900f)


# Self-evaluation

## Difficulties
今回、開発する上で苦戦した部分は大きく2つある。

1つ目はフロントエンドのリファクタリングである。イベントをハンドリングする上でuseStateが肥大化してしまったため、useStateのみを別のtsファイルに切り離すことにした。
ただ、useState内でも様々なイベント（ex. コマの初期配置、コマの移動など）がそれぞれ巨大化してしまったため、イベントごとに別々のtsファイルとして切り離すことにした。
しかし、useStateで管理されている変数が多すぎる上に、各イベントで共通して使用されていたものも多かったため、リファクタリングが困難になってしまった。解決策としてStateのリフトアップを行うことで状態管理を改善することができた。

2つ目はREST APIの構築である。今回初めてAPIを開発することになったため、Django Rest FrameworkがAPIの構築に便利なツールといえど、仕様の把握に苦戦した。特に、クラスの設計が直列な関係にあったため、JSONがネストされた構造になっていたため、SerializeやDeserializeのフローを追うことに苦戦した。また、ゲーム開始時にゲームデータをDeserializeする時とゲーム中にデータをDeserializeする際にリクエストで送るデータの項目が異なっていたため、開発が進むにつれてクラスの__init__メソッドを変更しなければならなかったことが当初の設計の粗さを痛感した。そこで、__init__メソッドにデフォルトの引数を用意することや、引数の数自体を増やすことで対処した。ただし、引数の数が多くなりすぎないように、クラスを引数に入れることで、可読性や依存関係を明確にすることを注意した。

## What I learned from this project
苦戦した部分と共通するが、大きく2点ある。

1つ目はセキュリティに関する知識がついたことだ。Djangoはデフォルトでセキュリティ対策が豊富なフレームワークであるが、
今回はフロントエンドとバックエンドを分離しているためにCORS周りの設定をカスタマイズしなければならなかった。
その過程でCSRF攻撃がどのようなものか理解し、CORSやCookieの設定を適切に行うことができた。
また、開発環境と本番環境での設定の違いや、環境変数を用意することで重要な情報を隠蔽するといったセキュリティマネジメントも学ぶことができた。

2つ目はREST APIに関する知識がついたことだ。今まではフロントエンドとバックエンドを分離した開発は行ってこなかったため、そもそもRESTという概念さえ聞いたことがあるという程度の理解だった。
しかし、REST APIについて学習していく中でURIをリソースに紐づけることやステートレスなやりとりを行うことで拡張性を高められるということを学んだ。
また、HTTPステータスコードの読み方も学習したため、APIで起こっているエラーを調査する時にどこで問題が起こっているのか素早く改修することができたのは学びだったといえる。
